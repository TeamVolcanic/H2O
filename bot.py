import discord
from discord import app_commands
from discord.ext import commands
import os
import datetime
import asyncio
import json
from collections import deque
from dotenv import load_dotenv

# Try to import Gemini client, but allow the bot to run without it.
AI_AVAILABLE = False
try:
    import google.generativeai as genai
    from google.generativeai.types import GenerationConfig
    from google.generativeai.errors import APIError
    AI_AVAILABLE = True
except ModuleNotFoundError:
    genai = None
    GenerationConfig = None
    APIError = Exception
    print("‚ö†Ô∏è google.generativeai not installed. AI features will be disabled. Add 'google-generative-ai' to requirements.txt and redeploy.")

# --- Configuration & Setup ---
load_dotenv()

# The Gemini key is read from env var GEMINI_API_KEY
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY")

# Initialize Gemini Client only if library + key are present
GEMINI_MODEL = "gemini-2.5-flash"
if AI_AVAILABLE and GEMINI_API_KEY:
    genai.configure(api_key=GEMINI_API_KEY)
    print(f"‚úÖ Gemini client configured with {GEMINI_MODEL}.")
else:
    if not AI_AVAILABLE:
        print("‚ùå GEMINI client library missing: AI features are disabled.")
    elif not GEMINI_API_KEY:
        print("‚ùå GEMINI_API_KEY not found: AI features are disabled.")

# Configuration for the Discord Bot
intents = discord.Intents.default()
intents.message_content = True  # Required to read message content for chat
intents.members = True  # Required for member checks
bot = commands.Bot(command_prefix="!", intents=intents)

# --- Bot Feature Variables ---
VERIFY_ROLE_NAME = "üßëÔ∏±Member"
COMMANDS_DATA_FILE = "commands_data.json"
TICKETS_DATA_FILE = "tickets_data.json"
TICKET_CATEGORY_NAME = "Tickets"

AI_SYSTEM_INSTRUCTION = (
    "You are an engaging, detailed, and creative assistant. "
    "Your response must *always* be presented as a single, comprehensive paragraph or summary. "
    "Crucially, you must heavily incorporate relevant and descriptive emojis throughout the text "
    "to make the message visually appealing and expressive. "
    "Do not include any prefaces, attribution, or headers like 'AI generated', 'Generated by User', or 'Here is your summary'."
)

# --- Gemini API Helper Function ---

async def chat_with_ai(messages: list):
    """
    Sends a list of messages to the Gemini API with the required system instruction.
    Returns an informative string if AI is disabled.
    """
    if not AI_AVAILABLE:
        return "Sorry, AI features are currently disabled on this deployment (missing package). ü§ñ"

    if not GEMINI_API_KEY:
        return "Sorry, AI features are currently disabled due to a missing GEMINI_API_KEY. üîí"

    # Configure generation with the system instruction
    config = GenerationConfig(system_instruction=AI_SYSTEM_INSTRUCTION)

    try:
        # Use a thread to call the synchronous client.generate_content if necessary
        response = await asyncio.to_thread(
            genai.client.models.generate_content,
            model=GEMINI_MODEL,
            contents=messages,
            config=config,
        )

        # Prefer response.text if present
        if getattr(response, "text", None):
            return response.text
        elif getattr(response, "candidates", None) and response.candidates:
            # If safety blocked or alternative content exists
            candidate = response.candidates[0]
            if getattr(candidate, "safety_ratings", None):
                return "üõ°Ô∏è Your request was blocked due to safety concerns. Please try a different query. üö´"
            return getattr(candidate, "content", "ü§ñ The AI returned an unexpected response.")
        else:
            return "ü§ñ I received an empty or malformed response from the AI. Please try again. üõ†Ô∏è"

    except APIError as e:
        print(f"Gemini API Error: {e}")
        return f"üö® I ran into an issue communicating with the AI model: {e} üíî"
    except Exception as e:
        print(f"General AI Error: {e}")
        return f"Oops! An unexpected error occurred while processing your request: {e} üêõ"

# --- Discord Event Handlers and Commands ---

@bot.event
async def on_ready():
    """Bot initialization event."""
    print(f'‚ú® Logged in as {bot.user} (ID: {bot.user.id})')
    print('------------------------------------------------')
    # Try to sync commands on ready
    try:
        synced = await bot.tree.sync()
        print(f"ü§ñ Synced {len(synced)} command(s) globally.")
    except Exception as e:
        print(f"‚ùå Failed to sync global commands on ready: {e}")

@bot.tree.command(name="sync", description="Sync slash commands to this server (Admin only)")
@app_commands.checks.has_permissions(administrator=True)
async def sync(interaction: discord.Interaction):
    """Syncs commands for the current guild."""
    try:
        await interaction.response.defer(ephemeral=True)
        bot.tree.copy_global_to(guild=interaction.guild)
        synced = await bot.tree.sync(guild=interaction.guild)
        embed = discord.Embed(
            title="‚úÖ Commands Synced",
            description=f"Successfully synced {len(synced)} commands to this server!\\n\\nAll slash commands should now be visible immediately. üöÄ",
            color=discord.Color.green()
        )
        embed.set_footer(text=f"Synced by {interaction.user.display_name}")
        await interaction.followup.send(embed=embed, ephemeral=True)
    except Exception as e:
        await interaction.followup.send(f"‚ùå Failed to sync commands: {e} üí•", ephemeral=True)

@bot.tree.command(name="ticket_create", description="Opens a new support ticket (no roles involved).")
async def ticket_create(interaction: discord.Interaction):
    """A placeholder for ticket creation without role management."""
    category = discord.utils.get(interaction.guild.categories, name=TICKET_CATEGORY_NAME)
    if not category:
        await interaction.response.send_message("‚ùå Ticket category not found. Please create a category named 'Tickets' first.", ephemeral=True)
        return

    overwrites = {
        interaction.guild.default_role: discord.PermissionOverwrite(read_messages=False),
        interaction.user: discord.PermissionOverwrite(read_messages=True, send_messages=True),
    }

    ticket_channel = await interaction.guild.create_text_channel(
        name=f"ticket-{interaction.user.name.lower().replace(' ', '-')}",
        category=category,
        overwrites=overwrites
    )

    await interaction.response.send_message(f"üì¨ Your ticket has been created: {ticket_channel.mention} üéâ", ephemeral=True)

    ticket_embed = discord.Embed(
        title="New Support Ticket",
        description=f"Welcome, {interaction.user.mention}! A member of our team will assist you shortly. Please describe your issue in detail. üìù",
        color=discord.Color.blue(),
        timestamp=datetime.datetime.now()
    )
    await ticket_channel.send(content=f"{interaction.user.mention}", embed=ticket_embed)

@bot.event
async def on_message(message: discord.Message):
    """Listens for direct mentions to engage the AI."""
    if message.author == bot.user:
        return

    if bot.user.mentioned_in(message) or (message.reference and message.reference.resolved and message.reference.resolved.author == bot.user):

        if not AI_AVAILABLE or not GEMINI_API_KEY:
            await message.channel.send("AI is currently disabled. üòî")
            return

        async with message.channel.typing():
            history = []
            raw_messages = [msg async for msg in message.channel.history(limit=10, before=message)]
            raw_messages.append(message)

            for msg in raw_messages:
                if msg.author == bot.user:
                    role = "model"
                elif msg.author.bot:
                    continue
                else:
                    role = "user"

                content = msg.clean_content.replace(f"@{bot.user.display_name}", "").strip()
                if content:
                    history.append({"role": role, "parts": [{"text": content}]})

            ai_response = await chat_with_ai(history)
            await message.reply(ai_response)

    await bot.process_commands(message)

# --- Bot Runner ---
DISCORD_TOKEN = os.environ.get("DISCORD_TOKEN")

if not DISCORD_TOKEN:
    print("FATAL ERROR: DISCORD_TOKEN environment variable is not set. The bot cannot start.")
else:
    try:
        bot.run(DISCORD_TOKEN)
    except discord.errors.LoginFailure:
        print("FATAL ERROR: Invalid Discord token provided. Please check your DISCORD_TOKEN.")
    except Exception as e:
        print(f"An unexpected error occurred during bot execution: {e}")
